<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Export Hybrid Transition Video (9:16)</title>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #2c3e50;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        
        #canvas {
            border: 2px solid #3498db;
            display: block;
            margin: 20px auto;
            background: white;
        }
        
        .upload-section {
            background: rgba(52, 152, 219, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 600px;
            border: 2px solid #3498db;
        }
        
        .upload-group {
            margin: 15px 0;
        }
        
        .upload-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #3498db;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #3498db;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
        }
        
        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 15px;
            background: #3498db;
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            margin-right: 10px;
        }
        
        input[type="file"]::-webkit-file-upload-button:hover {
            background: #2980b9;
        }
        
        .preview {
            margin-top: 10px;
            text-align: center;
        }
        
        .preview img {
            max-width: 150px;
            max-height: 150px;
            border: 2px solid #3498db;
            border-radius: 5px;
            background: white;
        }
        
        .info-box {
            background: rgba(241, 196, 15, 0.1);
            border: 2px solid #f1c40f;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .controls {
            text-align: center;
            margin: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        button {
            padding: 15px 30px;
            font-size: 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-width: 200px;
        }
        
        button:hover:not(:disabled) {
            background: #2980b9;
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        
        .status {
            text-align: center;
            margin: 10px;
            font-size: 16px;
            color: #ecf0f1;
            min-height: 24px;
        }
        
        .status.success {
            color: #2ecc71;
        }
        
        .status.error {
            color: #e74c3c;
        }
        
        .status.recording {
            color: #f39c12;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Export 9:16 Hybrid Transition Video</h1>
    <p style="text-align: center; color: #bdc3c7;">
        Aspect Ratio: 9:16 (Portrait) | Background: White
    </p>
    
    <div class="upload-section">
        <h3 style="margin-top: 0; color: #3498db;">üì∏ Upload Images for Transition</h3>
        <div class="info-box">
            <strong>‚ÑπÔ∏è Note:</strong> Upload two images to create a hybrid particle transition video. 
            For best results, use images with similar dimensions.
        </div>
        
        <div class="upload-group">
            <label for="image1Input">Source Image (Image 1):</label>
            <input type="file" id="image1Input" accept="image/*">
            <div class="preview" id="preview1"></div>
        </div>
        
        <div class="upload-group">
            <label for="image2Input">Target Image (Image 2):</label>
            <input type="file" id="image2Input" accept="image/*">
            <div class="preview" id="preview2"></div>
        </div>
    </div>
    
    <canvas id="canvas" width="720" height="1280"></canvas>
    
    <div class="controls">
        <button id="startBtn" disabled>Start Recording & Transition</button>
        <button id="downloadBtn" disabled>Download Video</button>
    </div>
    
    <div class="status" id="status">Please upload two images to begin</div>
    
    <script type="module">
        import { HybridEngine } from './src/HybridEngine.js';
        
        // Constants
        const FINAL_BUFFER_TIME = 500; // Extra time (ms) to ensure recording captures everything
        
        const canvas = document.getElementById('canvas');
        const status = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const image1Input = document.getElementById('image1Input');
        const image2Input = document.getElementById('image2Input');
        const preview1 = document.getElementById('preview1');
        const preview2 = document.getElementById('preview2');
        
        let engine = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let videoBlob = null;
        let uploadedImage1 = null;
        let uploadedImage2 = null;
        let ffmpeg = null;
        let ffmpegLoaded = false;
        
        // Initialize FFmpeg
        async function loadFFmpeg() {
            if (ffmpegLoaded) return true;
            
            try {
                updateStatus('Loading video converter...', 'info');
                const { FFmpeg } = FFmpegWASM;
                const { fetchFile, toBlobURL } = FFmpegUtil;
                
                ffmpeg = new FFmpeg();
                
                // Load FFmpeg core
                const baseURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd';
                await ffmpeg.load({
                    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });
                
                ffmpegLoaded = true;
                return true;
            } catch (error) {
                console.error('Failed to load FFmpeg:', error);
                updateStatus('Warning: Video converter failed to load. Videos will save as WebM.', 'error');
                return false;
            }
        }
        
        // Convert WebM to MP4
        async function convertToMP4(webmBlob) {
            if (!ffmpegLoaded) {
                console.warn('FFmpeg not loaded, returning WebM blob');
                return webmBlob;
            }
            
            try {
                updateStatus('Converting to MP4 format...', 'recording');
                const { fetchFile } = FFmpegUtil;
                
                // Write WebM file to FFmpeg virtual filesystem
                await ffmpeg.writeFile('input.webm', await fetchFile(webmBlob));
                
                // Convert to MP4 with H.264 codec
                await ffmpeg.exec([
                    '-i', 'input.webm',
                    '-c:v', 'libx264',
                    '-preset', 'fast',
                    '-crf', '22',
                    '-movflags', '+faststart',
                    'output.mp4'
                ]);
                
                // Read the output file
                const data = await ffmpeg.readFile('output.mp4');
                const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
                
                // Clean up
                await ffmpeg.deleteFile('input.webm');
                await ffmpeg.deleteFile('output.mp4');
                
                return mp4Blob;
            } catch (error) {
                console.error('Conversion failed:', error);
                updateStatus('Conversion failed, using WebM format', 'error');
                return webmBlob;
            }
        }
        
        // Update status message
        function updateStatus(message, type = '') {
            status.textContent = message;
            status.className = 'status ' + type;
        }
        
        // Handle file upload for image 1
        image1Input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage1 = img;
                        preview1.innerHTML = `<img src="${event.target.result}" alt="Image 1 Preview">`;
                        checkImagesReady();
                    };
                    img.onerror = () => {
                        updateStatus('Error: Invalid image file for Image 1', 'error');
                        preview1.innerHTML = '';
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    updateStatus('Error: Failed to read Image 1 file', 'error');
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Handle file upload for image 2
        image2Input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage2 = img;
                        preview2.innerHTML = `<img src="${event.target.result}" alt="Image 2 Preview">`;
                        checkImagesReady();
                    };
                    img.onerror = () => {
                        updateStatus('Error: Invalid image file for Image 2', 'error');
                        preview2.innerHTML = '';
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    updateStatus('Error: Failed to read Image 2 file', 'error');
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Check if both images are uploaded
        function checkImagesReady() {
            if (uploadedImage1 && uploadedImage2) {
                startBtn.disabled = false;
                updateStatus('Images ready! Click "Start Recording" to begin.', 'success');
            }
        }
        
        // Load images (now uses uploaded images)
        async function loadImages() {
            if (!uploadedImage1 || !uploadedImage2) {
                throw new Error('Please upload both images first');
            }
            
            updateStatus('Using uploaded images...', 'success');
            return { image1: uploadedImage1, image2: uploadedImage2 };
        }
        
        // Initialize HybridEngine
        function initializeEngine() {
            updateStatus('Initializing particle engine...');
            
            engine = new HybridEngine(canvas, {
                particleCount: 3000,
                speed: 1.0,
                enableTriangulation: true,
                triangulationMode: 'hybrid',
                gridSize: 8
            });
            
            updateStatus('Engine initialized', 'success');
        }
        
        // Setup MediaRecorder
        function setupRecorder() {
            updateStatus('Setting up video recorder...');
            
            const stream = canvas.captureStream(60); // 60 FPS
            const options = {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 8000000 // 8 Mbps for high quality
            };
            
            // Fallback to vp8 if vp9 is not supported
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm;codecs=vp8';
            }
            
            // Fallback to default if webm is not supported
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
            recordedChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                const webmBlob = new Blob(recordedChunks, { type: 'video/webm' });
                updateStatus('Recording complete, converting to MP4...', 'recording');
                
                // Convert to MP4
                videoBlob = await convertToMP4(webmBlob);
                
                updateStatus('Video ready! Click download to save.', 'success');
                downloadBtn.disabled = false;
            };
            
            updateStatus('Recorder ready', 'success');
        }
        
        // Start hybrid transition
        async function startTransition(image1, image2) {
            updateStatus('Starting transition...', 'recording');
            
            // Initialize engine with first image
            engine.initializeFromImage(image1);
            engine.start();
            
            // Wait a bit for the engine to be fully ready
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configure transition parameters
            const config = {
                explosionIntensity: 150,
                explosionTime: 1000,
                recombinationDuration: 2500,
                blendDuration: 2000,
                recombinationChaos: 0.3,
                vacuumStrength: 0.15,
                particleFadeRate: 0.7,
                staticDisplayDuration: 1000,  // Show source image for 1s
                disintegrationDuration: 1200  // Disintegrate over 1.2s
            };
            
            // Set render mode and start transition
            engine.setRenderMode('hybrid');
            engine.startHybridTransition(image1, image2, config);
            
            // Calculate total duration
            const totalDuration = config.staticDisplayDuration + 
                                  config.disintegrationDuration +
                                  config.explosionTime + 
                                  config.recombinationDuration + 
                                  config.blendDuration + 
                                  1000; // Extra time for final state
            
            updateStatus(`Recording (${Math.round(totalDuration / 1000)}s)...`, 'recording');
            
            // Wait for transition to complete
            await new Promise(resolve => setTimeout(resolve, totalDuration));
            
            updateStatus('Transition complete, finalizing video...', 'recording');
            
            // Give a bit more time to ensure everything is captured
            await new Promise(resolve => setTimeout(resolve, FINAL_BUFFER_TIME));
        }
        
        // Download video
        function downloadVideo() {
            if (!videoBlob) {
                updateStatus('No video to download', 'error');
                return;
            }
            
            const url = URL.createObjectURL(videoBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            // Determine file extension based on blob type
            const extension = videoBlob.type.includes('mp4') ? 'mp4' : 'webm';
            a.download = `hybrid-transition-9x16.${extension}`;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }, 100);
            
            updateStatus('Video downloaded!', 'success');
        }
        
        // Main recording workflow
        async function startRecordingAndTransition() {
            try {
                startBtn.disabled = true;
                downloadBtn.disabled = true;
                
                // Load FFmpeg for MP4 conversion
                await loadFFmpeg();
                
                // Load images
                const { image1, image2 } = await loadImages();
                
                // Initialize engine
                initializeEngine();
                
                // Setup recorder
                setupRecorder();
                
                // Start recording
                mediaRecorder.start();
                updateStatus('Recording started...', 'recording');
                
                // Run transition
                await startTransition(image1, image2);
                
                // Stop recording
                mediaRecorder.stop();
                
            } catch (error) {
                console.error('Error during recording:', error);
                updateStatus(`Error: ${error.message}`, 'error');
                startBtn.disabled = false;
            }
        }
        
        // Event listeners
        startBtn.addEventListener('click', startRecordingAndTransition);
        downloadBtn.addEventListener('click', downloadVideo);
        
        // Initial status
        updateStatus('Ready to record. Click "Start Recording & Transition" to begin.');
    </script>
</body>
</html>
