<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Export Hybrid Transition Video (9:16)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #2c3e50;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        
        #canvas {
            border: 2px solid #3498db;
            display: block;
            margin: 20px auto;
            background: white;
        }
        
        .upload-section {
            background: rgba(52, 152, 219, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 600px;
            border: 2px solid #3498db;
        }
        
        .upload-group {
            margin: 15px 0;
        }
        
        .upload-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #3498db;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #3498db;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
        }
        
        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 15px;
            background: #3498db;
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            margin-right: 10px;
        }
        
        input[type="file"]::-webkit-file-upload-button:hover {
            background: #2980b9;
        }
        
        .preview {
            margin-top: 10px;
            text-align: center;
        }
        
        .preview img {
            max-width: 150px;
            max-height: 150px;
            border: 2px solid #3498db;
            border-radius: 5px;
            background: white;
        }
        
        .info-box {
            background: rgba(241, 196, 15, 0.1);
            border: 2px solid #f1c40f;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .controls {
            text-align: center;
            margin: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        button {
            padding: 15px 30px;
            font-size: 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-width: 200px;
        }
        
        button:hover:not(:disabled) {
            background: #2980b9;
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        
        button.secondary {
            background: #95a5a6;
        }
        
        button.secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }
        
        button.success {
            background: #27ae60;
        }
        
        button.success:hover:not(:disabled) {
            background: #229954;
        }
        
        button.warning {
            background: #e67e22;
        }
        
        button.warning:hover:not(:disabled) {
            background: #d35400;
        }
        
        .status {
            text-align: center;
            margin: 10px;
            font-size: 16px;
            color: #ecf0f1;
            min-height: 24px;
        }
        
        .status.success {
            color: #2ecc71;
        }
        
        .status.error {
            color: #e74c3c;
        }
        
        .status.recording {
            color: #f39c12;
            font-weight: bold;
        }
        
        .status.info {
            color: #3498db;
        }
        
        .slider-group {
            margin: 15px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ecf0f1;
        }
        
        .slider-value {
            color: #3498db;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            background: #2980b9;
        }
        
        .controls-section {
            background: rgba(52, 152, 219, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 600px;
            border: 2px solid #3498db;
        }
        
        .controls-section h3 {
            margin-top: 0;
            color: #3498db;
        }
    </style>
</head>
<body>
    <h1>Export 9:16 Hybrid Transition Video</h1>
    <p style="text-align: center; color: #bdc3c7;">
        Aspect Ratio: 9:16 (Portrait) | Background: White
    </p>
    
    <div class="upload-section">
        <h3 style="margin-top: 0; color: #3498db;">üì∏ Upload Images for Transition</h3>
        <div class="info-box">
            <strong>‚ÑπÔ∏è Note:</strong> Upload two images to create a hybrid particle transition video. 
            For best results, use images with similar dimensions.
        </div>
        
        <div class="upload-group">
            <label for="image1Input">Source Image (Image 1):</label>
            <input type="file" id="image1Input" accept="image/*">
            <div class="preview" id="preview1"></div>
        </div>
        
        <div class="upload-group">
            <label for="image2Input">Target Image (Image 2):</label>
            <input type="file" id="image2Input" accept="image/*">
            <div class="preview" id="preview2"></div>
        </div>
    </div>
    
    <div class="controls-section">
        <h3>üéÆ Hybrid Transition Controls</h3>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Particle Count:</span>
                <span class="slider-value" id="particleCountValue">3000</span>
            </div>
            <input type="range" id="particleCountSlider" min="500" max="5000" step="100" value="3000">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Static Display Duration (ms):</span>
                <span class="slider-value" id="staticDisplayDurationValue">1000</span>
            </div>
            <input type="range" id="staticDisplayDuration" min="0" max="2000" step="100" value="1000">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Disintegration Duration (ms):</span>
                <span class="slider-value" id="disintegrationDurationValue">1200</span>
            </div>
            <input type="range" id="disintegrationDuration" min="500" max="3000" step="100" value="1200">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Explosion Intensity:</span>
                <span class="slider-value" id="explosionIntensityValue">150</span>
            </div>
            <input type="range" id="explosionIntensity" min="50" max="300" value="150">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Explosion Time (ms):</span>
                <span class="slider-value" id="explosionTimeValue">1000</span>
            </div>
            <input type="range" id="explosionTime" min="300" max="2000" step="100" value="1000">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Recombination Duration (ms):</span>
                <span class="slider-value" id="recombinationDurationValue">2500</span>
            </div>
            <input type="range" id="recombinationDuration" min="1000" max="4000" step="100" value="2500">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Blend Duration (ms):</span>
                <span class="slider-value" id="blendDurationValue">2000</span>
            </div>
            <input type="range" id="blendDuration" min="500" max="3000" step="100" value="2000">
        </div>
        
        <div class="info-box">
            <strong>üí° Tip:</strong> Adjust these sliders to control the hybrid transition effect. 
            Changes will be applied to the next recording.
        </div>
    </div>
    
    <div class="controls-section">
        <h3>üß≤ Ferrofluid Physics Controls</h3>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Enable Ferrofluid Physics:</span>
                <input type="checkbox" id="enableFerrofluid" checked style="width: auto; height: 20px; margin-left: 10px; cursor: pointer;">
            </div>
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Cohesion Strength:</span>
                <span class="slider-value" id="cohesionStrengthValue">0.2</span>
            </div>
            <input type="range" id="cohesionStrength" min="0" max="0.4" step="0.01" value="0.2">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Surface Tension:</span>
                <span class="slider-value" id="surfaceTensionValue">0.25</span>
            </div>
            <input type="range" id="surfaceTension" min="0" max="0.5" step="0.01" value="0.25">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Enable Image Containers:</span>
                <input type="checkbox" id="enableContainer" checked style="width: auto; height: 20px; margin-left: 10px; cursor: pointer;">
            </div>
        </div>
        
        <div class="slider-group">
            <div class="slider-label">
                <span>Container Padding (px):</span>
                <span class="slider-value" id="containerPaddingValue">10</span>
            </div>
            <input type="range" id="containerPadding" min="0" max="50" step="5" value="10">
        </div>
        
        <div class="info-box">
            <strong>üß≤ Ferrofluid Features:</strong> Enable blob-like particle clustering and container-based physics for organic, fluid transitions.
        </div>
    </div>
    
    <canvas id="canvas" width="720" height="1280"></canvas>
    
    <div class="controls">
        <button id="testBtn" class="secondary" disabled>Test Transition (Preview)</button>
        <button id="resetBtn" class="warning" disabled>Reset</button>
        <button id="startBtn" class="success" disabled>Start Recording</button>
        <button id="downloadBtn" disabled>Download Video</button>
    </div>
    
    <div class="status" id="status">Please upload two images to begin</div>
    
    <script type="module">
        import { HybridEngine } from './src/HybridEngine.js';
        
        // Constants
        const FINAL_BUFFER_TIME = 500; // Extra time (ms) to ensure recording captures everything
        
        const canvas = document.getElementById('canvas');
        const status = document.getElementById('status');
        const testBtn = document.getElementById('testBtn');
        const resetBtn = document.getElementById('resetBtn');
        const startBtn = document.getElementById('startBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const image1Input = document.getElementById('image1Input');
        const image2Input = document.getElementById('image2Input');
        const preview1 = document.getElementById('preview1');
        const preview2 = document.getElementById('preview2');
        
        let engine = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let videoBlob = null;
        let uploadedImage1 = null;
        let uploadedImage2 = null;
        let ffmpeg = null;
        let ffmpegLoaded = false;
        let FFmpeg = null;
        let fetchFile = null;
        let toBlobURL = null;
        
        // Get slider elements
        const particleCountSlider = document.getElementById('particleCountSlider');
        const particleCountValue = document.getElementById('particleCountValue');
        const staticDisplayDuration = document.getElementById('staticDisplayDuration');
        const staticDisplayDurationValue = document.getElementById('staticDisplayDurationValue');
        const disintegrationDuration = document.getElementById('disintegrationDuration');
        const disintegrationDurationValue = document.getElementById('disintegrationDurationValue');
        const explosionIntensity = document.getElementById('explosionIntensity');
        const explosionIntensityValue = document.getElementById('explosionIntensityValue');
        const explosionTime = document.getElementById('explosionTime');
        const explosionTimeValue = document.getElementById('explosionTimeValue');
        const recombinationDuration = document.getElementById('recombinationDuration');
        const recombinationDurationValue = document.getElementById('recombinationDurationValue');
        const blendDuration = document.getElementById('blendDuration');
        const blendDurationValue = document.getElementById('blendDurationValue');
        
        // Get ferrofluid control elements
        const enableFerrofluid = document.getElementById('enableFerrofluid');
        const cohesionStrength = document.getElementById('cohesionStrength');
        const cohesionStrengthValue = document.getElementById('cohesionStrengthValue');
        const surfaceTension = document.getElementById('surfaceTension');
        const surfaceTensionValue = document.getElementById('surfaceTensionValue');
        const enableContainer = document.getElementById('enableContainer');
        const containerPadding = document.getElementById('containerPadding');
        const containerPaddingValue = document.getElementById('containerPaddingValue');
        
        // Add slider event listeners
        particleCountSlider.addEventListener('input', () => {
            particleCountValue.textContent = particleCountSlider.value;
        });
        
        staticDisplayDuration.addEventListener('input', () => {
            staticDisplayDurationValue.textContent = staticDisplayDuration.value;
        });
        
        disintegrationDuration.addEventListener('input', () => {
            disintegrationDurationValue.textContent = disintegrationDuration.value;
        });
        
        explosionIntensity.addEventListener('input', () => {
            explosionIntensityValue.textContent = explosionIntensity.value;
        });
        
        explosionTime.addEventListener('input', () => {
            explosionTimeValue.textContent = explosionTime.value;
        });
        
        recombinationDuration.addEventListener('input', () => {
            recombinationDurationValue.textContent = recombinationDuration.value;
        });
        
        blendDuration.addEventListener('input', () => {
            blendDurationValue.textContent = blendDuration.value;
        });
        
        // Add ferrofluid slider event listeners
        cohesionStrength.addEventListener('input', () => {
            cohesionStrengthValue.textContent = cohesionStrength.value;
        });
        
        surfaceTension.addEventListener('input', () => {
            surfaceTensionValue.textContent = surfaceTension.value;
        });
        
        containerPadding.addEventListener('input', () => {
            containerPaddingValue.textContent = containerPadding.value;
        });
        
        // Initialize FFmpeg
        async function loadFFmpeg() {
            if (ffmpegLoaded) return true;
            
            try {
                updateStatus('Loading video converter (MP4 support)...', 'info');
                
                // Dynamically import FFmpeg modules
                const ffmpegModule = await import('https://esm.sh/@ffmpeg/ffmpeg@0.12.10');
                const utilModule = await import('https://esm.sh/@ffmpeg/util@0.12.1');
                
                FFmpeg = ffmpegModule.FFmpeg;
                fetchFile = utilModule.fetchFile;
                toBlobURL = utilModule.toBlobURL;
                
                ffmpeg = new FFmpeg();
                
                // Load FFmpeg core
                const baseURL = 'https://esm.sh/@ffmpeg/core@0.12.6/dist/esm';
                await ffmpeg.load({
                    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });
                
                ffmpegLoaded = true;
                console.log('FFmpeg loaded successfully - MP4 export available');
                updateStatus('Video converter loaded - MP4 export enabled', 'success');
                return true;
            } catch (error) {
                console.error('Failed to load FFmpeg:', error);
                console.log('Videos will be saved as WebM format. You can convert them to MP4 using online tools or FFmpeg command line.');
                updateStatus('Warning: MP4 converter failed to load. Videos will be saved as WebM.', 'error');
                ffmpegLoaded = false;
                return false;
            }
        }
        
        // Convert WebM to MP4
        async function convertToMP4(inputBlob) {
            if (!ffmpegLoaded) {
                console.warn('FFmpeg not loaded, returning original blob');
                return inputBlob;
            }
            
            // If input is already MP4, no conversion needed
            if (inputBlob.type.includes('mp4')) {
                console.log('Input is already MP4, skipping conversion');
                return inputBlob;
            }
            
            try {
                updateStatus('Converting to MP4 format (this may take a moment)...', 'recording');
                console.log('Starting MP4 conversion...');
                
                // Write WebM file to FFmpeg virtual filesystem
                await ffmpeg.writeFile('input.webm', await fetchFile(inputBlob));
                console.log('WebM file written to FFmpeg filesystem');
                
                // Convert to MP4 with H.264 codec
                await ffmpeg.exec([
                    '-i', 'input.webm',
                    '-c:v', 'libx264',
                    '-preset', 'fast',
                    '-crf', '22',
                    '-movflags', '+faststart',
                    'output.mp4'
                ]);
                console.log('FFmpeg conversion completed');
                
                // Read the output file
                const data = await ffmpeg.readFile('output.mp4');
                const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
                console.log('MP4 blob created, size:', mp4Blob.size, 'bytes, type:', mp4Blob.type);
                
                // Clean up
                await ffmpeg.deleteFile('input.webm');
                await ffmpeg.deleteFile('output.mp4');
                console.log('Temporary files cleaned up');
                
                return mp4Blob;
            } catch (error) {
                console.error('Conversion failed:', error);
                updateStatus('Conversion failed, using original format', 'error');
                return inputBlob;
            }
        }
        
        // Update status message
        function updateStatus(message, type = '') {
            status.textContent = message;
            status.className = 'status ' + type;
        }
        
        // Handle file upload for image 1
        image1Input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage1 = img;
                        preview1.innerHTML = `<img src="${event.target.result}" alt="Image 1 Preview">`;
                        checkImagesReady();
                    };
                    img.onerror = () => {
                        updateStatus('Error: Invalid image file for Image 1', 'error');
                        preview1.innerHTML = '';
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    updateStatus('Error: Failed to read Image 1 file', 'error');
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Handle file upload for image 2
        image2Input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage2 = img;
                        preview2.innerHTML = `<img src="${event.target.result}" alt="Image 2 Preview">`;
                        checkImagesReady();
                    };
                    img.onerror = () => {
                        updateStatus('Error: Invalid image file for Image 2', 'error');
                        preview2.innerHTML = '';
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    updateStatus('Error: Failed to read Image 2 file', 'error');
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Check if both images are uploaded
        function checkImagesReady() {
            if (uploadedImage1 && uploadedImage2) {
                testBtn.disabled = false;
                startBtn.disabled = false;
                updateStatus('Images ready! Test the transition or start recording.', 'success');
            }
        }
        
        // Load images (now uses uploaded images)
        async function loadImages() {
            if (!uploadedImage1 || !uploadedImage2) {
                throw new Error('Please upload both images first');
            }
            
            updateStatus('Using uploaded images...', 'success');
            return { image1: uploadedImage1, image2: uploadedImage2 };
        }
        
        // Initialize HybridEngine
        function initializeEngine() {
            updateStatus('Initializing particle engine...');
            
            const particleCount = parseInt(particleCountSlider.value, 10);
            
            engine = new HybridEngine(canvas, {
                particleCount: particleCount,
                speed: 1.0,
                enableTriangulation: true,
                triangulationMode: 'hybrid',
                gridSize: 8
            });
            
            updateStatus('Engine initialized', 'success');
        }
        
        // Setup MediaRecorder
        function setupRecorder() {
            updateStatus('Setting up video recorder...');
            
            const stream = canvas.captureStream(60); // 60 FPS
            
            // Try different codec options in order of preference
            const codecOptions = [
                { mimeType: 'video/webm;codecs=vp9', container: 'webm', name: 'WebM (VP9)' },
                { mimeType: 'video/webm;codecs=vp8', container: 'webm', name: 'WebM (VP8)' },
                { mimeType: 'video/webm', container: 'webm', name: 'WebM' },
                // Safari/Mac fallback options - use complete codec strings for better compatibility
                { mimeType: 'video/mp4;codecs=avc1.42E01E', container: 'mp4', name: 'MP4 (H.264 Baseline)' },
                { mimeType: 'video/mp4;codecs=avc1', container: 'mp4', name: 'MP4 (H.264)' },
                { mimeType: 'video/mp4', container: 'mp4', name: 'MP4' }
            ];
            
            let selectedCodec = null;
            for (const codec of codecOptions) {
                if (MediaRecorder.isTypeSupported(codec.mimeType)) {
                    selectedCodec = codec;
                    console.log(`Using codec: ${codec.name} (${codec.mimeType})`);
                    break;
                }
            }
            
            if (!selectedCodec) {
                throw new Error('No supported video codec found. Please try a different browser.');
            }
            
            const options = {
                mimeType: selectedCodec.mimeType,
                videoBitsPerSecond: 8000000 // 8 Mbps for high quality
            };
            
            mediaRecorder = new MediaRecorder(stream, options);
            recordedChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                const recordedBlob = new Blob(recordedChunks, { type: selectedCodec.mimeType });
                
                // If recording is already MP4, use it directly (no conversion needed)
                if (selectedCodec.container === 'mp4') {
                    videoBlob = recordedBlob;
                    updateStatus('Video ready (MP4)! Click download to save.', 'success');
                } else if (selectedCodec.container === 'webm' && ffmpegLoaded) {
                    updateStatus('Recording complete, converting to MP4...', 'recording');
                    // Convert WebM to MP4
                    videoBlob = await convertToMP4(recordedBlob);
                    const format = videoBlob.type.includes('mp4') ? 'MP4' : 'WebM';
                    updateStatus(`Video ready (${format})! Click download to save.`, 'success');
                } else {
                    // Fallback: use recorded format as-is (WebM without FFmpeg)
                    videoBlob = recordedBlob;
                    const format = selectedCodec.container.toUpperCase();
                    updateStatus(`Video ready (${format})! Click download to save.`, 'success');
                }
                
                downloadBtn.disabled = false;
            };
            
            updateStatus(`Recorder ready (${selectedCodec.name})`, 'success');
        }
        
        // Start hybrid transition
        async function startTransition(image1, image2, isRecording = false) {
            const statusPrefix = isRecording ? 'Recording' : 'Testing';
            updateStatus(`${statusPrefix}: Starting transition...`, isRecording ? 'recording' : 'info');
            
            // Initialize engine with first image
            engine.initializeFromImage(image1);
            engine.start();
            
            // Wait a bit for the engine to be fully ready
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configure transition parameters from sliders
            const config = {
                explosionIntensity: parseInt(explosionIntensity.value, 10),
                explosionTime: parseInt(explosionTime.value, 10),
                recombinationDuration: parseInt(recombinationDuration.value, 10),
                blendDuration: parseInt(blendDuration.value, 10),
                recombinationChaos: 0.3,
                vacuumStrength: 0.15,
                particleFadeRate: 0.7,
                staticDisplayDuration: parseInt(staticDisplayDuration.value, 10),
                disintegrationDuration: parseInt(disintegrationDuration.value, 10),
                finalStaticDuration: 2000, // Display final image for 2 seconds
                
                // Ferrofluid physics parameters
                enableFerrofluid: enableFerrofluid.checked,
                cohesionStrength: parseFloat(cohesionStrength.value),
                surfaceTension: parseFloat(surfaceTension.value),
                
                // Container physics parameters
                enableContainer: enableContainer.checked,
                containerPadding: parseInt(containerPadding.value, 10)
            };
            
            // Set render mode and start transition
            engine.setRenderMode('hybrid');
            engine.startHybridTransition(image1, image2, config);
            
            // Calculate total duration - include all phases
            const totalDuration = config.staticDisplayDuration + 
                                  config.disintegrationDuration +
                                  config.explosionTime + 
                                  config.recombinationDuration + 
                                  config.blendDuration + 
                                  config.finalStaticDuration; // Final static image display
            
            updateStatus(`${statusPrefix} (${Math.round(totalDuration / 1000)}s)...`, isRecording ? 'recording' : 'info');
            
            // Wait for transition to complete
            await new Promise(resolve => setTimeout(resolve, totalDuration));
            
            if (isRecording) {
                updateStatus('Transition complete, finalizing video...', 'recording');
                
                // Give a bit more time to ensure everything is captured
                await new Promise(resolve => setTimeout(resolve, FINAL_BUFFER_TIME));
            }
        }
        
        // Download video
        function downloadVideo() {
            if (!videoBlob) {
                updateStatus('No video to download', 'error');
                return;
            }
            
            const url = URL.createObjectURL(videoBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            // Determine file extension based on blob type
            const extension = videoBlob.type.includes('mp4') ? 'mp4' : 'webm';
            a.download = `hybrid-transition-9x16.${extension}`;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }, 100);
            
            updateStatus('Video downloaded! You can test or record another video.', 'success');
            
            // Reset state to allow creating another video
            // Keep the videoBlob for potential re-download, but enable other actions
            testBtn.disabled = false;
            startBtn.disabled = false;
            resetBtn.disabled = false;
            // downloadBtn stays enabled in case user wants to download again
        }
        
        // Test transition without recording
        async function testTransition() {
            try {
                testBtn.disabled = true;
                startBtn.disabled = true;
                resetBtn.disabled = true;
                
                updateStatus('Loading test mode...', 'info');
                
                // Load images
                const { image1, image2 } = await loadImages();
                
                // Initialize engine
                initializeEngine();
                
                updateStatus('Testing transition (not recording)...', 'info');
                
                // Run transition
                await startTransition(image1, image2, false);
                
                updateStatus('Test complete! Adjust settings and test again, or start recording.', 'success');
                
                // Re-enable buttons after test
                testBtn.disabled = false;
                startBtn.disabled = false;
                resetBtn.disabled = false;
                
            } catch (error) {
                console.error('Error during test:', error);
                updateStatus(`Error: ${error.message}`, 'error');
                testBtn.disabled = false;
                startBtn.disabled = false;
                resetBtn.disabled = false;
            }
        }
        
        // Reset the canvas and engine
        function resetTransition() {
            try {
                updateStatus('Resetting...', 'info');
                
                // Stop and cleanup engine if exists
                if (engine) {
                    engine.stop();
                    engine = null;
                }
                
                // Clear the WebGL canvas
                if (canvas) {
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        gl.clearColor(1.0, 1.0, 1.0, 1.0); // White
                        gl.clear(gl.COLOR_BUFFER_BIT);
                    }
                }
                
                // Clear any video blob
                videoBlob = null;
                
                // Reset recorder
                mediaRecorder = null;
                recordedChunks = [];
                
                // Reset button states
                downloadBtn.disabled = true;
                testBtn.disabled = false;
                startBtn.disabled = false;
                resetBtn.disabled = false;
                
                updateStatus('Reset complete. Ready to test or record.', 'success');
                
            } catch (error) {
                console.error('Error during reset:', error);
                updateStatus(`Reset error: ${error.message}`, 'error');
            }
        }
        
        // Main recording workflow
        async function startRecordingAndTransition() {
            try {
                startBtn.disabled = true;
                testBtn.disabled = true;
                resetBtn.disabled = true;
                downloadBtn.disabled = true;
                
                // Load FFmpeg for MP4 conversion
                await loadFFmpeg();
                
                // Load images
                const { image1, image2 } = await loadImages();
                
                // Initialize engine
                initializeEngine();
                
                // Setup recorder
                setupRecorder();
                
                // Start recording
                mediaRecorder.start();
                updateStatus('Recording started...', 'recording');
                
                // Run transition
                await startTransition(image1, image2, true);
                
                // Stop recording
                mediaRecorder.stop();
                
            } catch (error) {
                console.error('Error during recording:', error);
                updateStatus(`Error: ${error.message}`, 'error');
                startBtn.disabled = false;
                testBtn.disabled = false;
                resetBtn.disabled = false;
            }
        }
        
        // Event listeners
        testBtn.addEventListener('click', testTransition);
        resetBtn.addEventListener('click', resetTransition);
        startBtn.addEventListener('click', startRecordingAndTransition);
        downloadBtn.addEventListener('click', downloadVideo);
        
        // Initial status
        updateStatus('Please upload two images to begin.');
    </script>
</body>
</html>
