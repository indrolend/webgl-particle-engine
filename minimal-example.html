<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal WebGL Particle Example</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: monospace;
            color: #fff;
        }
        canvas {
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="info">Minimal WebGL Particle Animation - No Dependencies</div>
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        // Minimal WebGL Particle Animation
        // This example demonstrates basic particle animation without external dependencies
        
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Vertex shader - handles particle positioning
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec4 a_color;
            uniform vec2 u_resolution;
            varying vec4 v_color;
            
            void main() {
                // Convert from pixels to clip space (-1 to 1)
                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
                gl_PointSize = 3.0;
                v_color = a_color;
            }
        `;

        // Fragment shader - handles particle coloring
        const fragmentShaderSource = `
            precision mediump float;
            varying vec4 v_color;
            
            void main() {
                gl_FragColor = v_color;
            }
        `;

        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        if (!vertexShader || !fragmentShader) {
            throw new Error('Failed to compile shaders');
        }
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const error = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error('Program link error: ' + error);
        }
        
        gl.useProgram(program);

        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const colorLocation = gl.getAttribLocation(program, 'a_color');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

        // Particle data structure
        const particleCount = 500;
        const particles = [];
        
        // Initialize particles with random positions and velocities
        for (let i = 0; i < particleCount; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                r: Math.random() * 0.5 + 0.5,
                g: Math.random() * 0.5 + 0.5,
                b: Math.random() * 0.5 + 0.5,
                a: 1.0
            });
        }

        // Create buffers
        const positionBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();

        // Allocate typed arrays once (reused every frame for better performance)
        const positions = new Float32Array(particleCount * 2);
        const colors = new Float32Array(particleCount * 4);

        // Set resolution uniform
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

        // Set up vertex attributes once
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW); // Allocate buffer storage
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW); // Allocate buffer storage
        gl.enableVertexAttribArray(colorLocation);
        gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);

        // Animation loop
        function animate() {
            // Update particle positions
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                // Update position
                p.x += p.vx;
                p.y += p.vy;
                
                // Bounce off edges (with proper boundary checks)
                if (p.x <= 0 || p.x >= canvas.width) {
                    p.vx *= -1;
                    p.x = Math.max(0, Math.min(canvas.width, p.x));
                }
                if (p.y <= 0 || p.y >= canvas.height) {
                    p.vy *= -1;
                    p.y = Math.max(0, Math.min(canvas.height, p.y));
                }
            }

            // Fill reusable arrays with particle data
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                positions[i * 2] = p.x;
                positions[i * 2 + 1] = p.y;
                colors[i * 4] = p.r;
                colors[i * 4 + 1] = p.g;
                colors[i * 4 + 2] = p.b;
                colors[i * 4 + 3] = p.a;
            }

            // Update position buffer (use bufferSubData for better performance)
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, positions);

            // Update color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, colors);

            // Clear and render
            gl.clearColor(0.05, 0.05, 0.05, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, particles.length);

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>
