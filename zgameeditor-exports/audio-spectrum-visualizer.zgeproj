<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="AudioSpectrumVisualizer" Caption="Audio Spectrum Visualizer - Audio Reactive" CameraPosition="0 0 10" ViewportRatio="3" CustomViewportRatio="1.7778" ScreenMode="0" FOV="90" TargetFrameRate="60" AndroidPackageName="com.zgameeditor.audiospectrum">
  <OnLoaded>
    <ZExternalLibrary Comment="Audio Data Arrays">
      <Source>
<![CDATA[// Audio data arrays for FL Studio integration
float[] SpecBandArray;
float[] AudioArray;
float SongPositionInBeats;

// Audio processing variables
float bass, mid, high, amplitude, beat;

// Smoothed spectrum for visualization
float[] smoothedSpectrum;]]>
      </Source>
    </ZExternalLibrary>
    
    <Array Name="SpecBandArray" Type="1" Dimensions="1" SizeDim1="32" Persistent="255"/>
    <Array Name="AudioArray" Type="1" Dimensions="1" SizeDim1="32" Persistent="255"/>
    <Array Name="smoothedSpectrum" Type="1" Dimensions="1" SizeDim1="32"/>
    <Variable Name="SongPositionInBeats" Type="1"/>
    
    <Array Name="Parameters" Type="1" Dimensions="1" SizeDim1="5" Persistent="1"/>
    
    <Constant Name="ParamHelpConst" Type="1">
      <StringValue>Bar Count (16-128)
Bar Spacing (0.0-0.3)
Height Scale (0.5-2.0)
Smoothing (0.0-0.95)
Visual Mode (0-2)</StringValue>
    </Constant>
    
    <Variable Name="u_barCount"/>
    <Variable Name="u_barSpacing"/>
    <Variable Name="u_heightScale"/>
    <Variable Name="u_smoothing"/>
    <Variable Name="u_visualMode"/>
    <Variable Name="iBeat"/>
    <Variable Name="iBass"/>
    <Variable Name="iMid"/>
    <Variable Name="iHigh"/>
    <Variable Name="iAmplitude"/>
  </OnLoaded>
  
  <OnUpdate>
    <ZExpression Comment="Process Audio">
      <Expression>
<![CDATA[bass = 0;
for(int i=0; i<5; i++) bass += SpecBandArray[i];
bass = bass / 5.0;

mid = 0;
for(int i=5; i<16; i++) mid += SpecBandArray[i];
mid = mid / 11.0;

high = 0;
for(int i=16; i<32; i++) high += SpecBandArray[i];
high = high / 16.0;

amplitude = 0;
for(int i=0; i<32; i++) amplitude += abs(AudioArray[i]);
amplitude = amplitude / 32.0;

beat = clamp(bass * 2.0 + amplitude * 0.5, 0, 1);

// Smooth spectrum for visualization
float smoothFactor = 1.0 - u_smoothing;
for(int i=0; i<32; i++) {
  smoothedSpectrum[i] = smoothedSpectrum[i] * (1.0 - smoothFactor) + SpecBandArray[i] * smoothFactor;
}

u_barCount = 16.0 + Parameters[0] * 112.0;
u_barSpacing = Parameters[1] * 0.3;
u_heightScale = 0.5 + Parameters[2] * 1.5;
u_smoothing = Parameters[3] * 0.95;
u_visualMode = floor(Parameters[4] * 2.999);

iBeat = beat;
iBass = bass;
iMid = mid;
iHigh = high;
iAmplitude = amplitude;]]>
      </Expression>
    </ZExpression>
  </OnUpdate>
  
  <OnRender>
    <RenderSetColor Color="0 0 0 1"/>
    <RenderClearScreen/>
    <UseMaterial Material="SpectrumMaterial"/>
    <RenderSprite/>
  </OnRender>
  
  <Content>
    <Material Name="SpectrumMaterial" Shading="1" Light="0" ZBuffer="0">
      <Shader>
        <VertexShaderSource>
<![CDATA[void main() {
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}]]>
        </VertexShaderSource>
        <FragmentShaderSource>
<![CDATA[// Audio Spectrum Visualizer - Classic audio spectrum analyzer
// Author: indrolend | License: MIT

precision mediump float;

uniform float iTime;
uniform float iBeat, iBass, iMid, iHigh, iAmplitude;
uniform float u_barCount, u_barSpacing, u_heightScale, u_smoothing, u_visualMode;

float beatPulse(float beat, float attack, float decay) {
    float t = fract(iTime * 2.0);
    float envelope = t < attack ? t / attack : 1.0 - ((t - attack) / decay);
    return beat * smoothstep(0.0, 1.0, envelope);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float getSpectrum(float freq) {
    // Simulate spectrum data from audio bands
    if (freq < 0.15625) {
        return iBass;
    } else if (freq < 0.5) {
        return iMid;
    } else {
        return iHigh;
    }
}

vec3 renderBars(vec2 uv, int barCount, float spacing, float heightScale) {
    vec3 color = vec3(0.0);
    
    float barWidth = (1.0 - spacing) / float(barCount);
    float totalWidth = barWidth + spacing / float(barCount);
    
    int barIndex = int(uv.x / totalWidth);
    if (barIndex >= 0 && barIndex < barCount) {
        float barX = float(barIndex) * totalWidth;
        float localX = (uv.x - barX) / barWidth;
        
        if (localX >= 0.0 && localX <= 1.0) {
            float freq = float(barIndex) / float(barCount);
            float spectrum = getSpectrum(freq);
            
            float barHeight = spectrum * heightScale;
            
            if (uv.y <= barHeight) {
                float hue = freq + iTime * 0.1;
                float brightness = uv.y / barHeight;
                
                color = hsv2rgb(vec3(hue, 0.8, brightness * 0.9 + 0.1));
                
                float glowDist = abs(uv.y - barHeight) / barHeight;
                color += vec3(1.0) * (1.0 - smoothstep(0.0, 0.05, glowDist)) * 0.5;
            }
            
            float outlineThickness = 0.003;
            if ((localX < outlineThickness || localX > 1.0 - outlineThickness) && uv.y <= barHeight) {
                color += vec3(0.3);
            }
        }
    }
    
    return color;
}

vec3 renderWaveform(vec2 uv, float heightScale) {
    vec3 color = vec3(0.0);
    
    float waveY = 0.5 + iAmplitude * sin(uv.x * 20.0 + iTime * 10.0) * heightScale * 0.3;
    
    float dist = abs(uv.y - waveY);
    float line = smoothstep(0.01, 0.005, dist);
    
    float hue = uv.x + iTime * 0.1;
    color = hsv2rgb(vec3(hue, 0.8, 0.9)) * line;
    
    color += vec3(1.0) * (1.0 - smoothstep(0.0, 0.03, dist)) * 0.3;
    
    return color;
}

vec3 renderCircular(vec2 uv, int barCount, float heightScale) {
    vec3 color = vec3(0.0);
    
    vec2 center = uv - vec2(0.5);
    float angle = atan(center.y, center.x);
    float radius = length(center);
    
    float normalizedAngle = (angle + 3.14159265359) / (2.0 * 3.14159265359);
    
    int barIndex = int(normalizedAngle * float(barCount));
    float freq = float(barIndex) / float(barCount);
    float spectrum = getSpectrum(freq);
    
    float innerRadius = 0.2;
    float barHeight = spectrum * heightScale * 0.3;
    float outerRadius = innerRadius + barHeight;
    
    if (radius >= innerRadius && radius <= outerRadius) {
        float hue = freq + iTime * 0.1;
        float brightness = (radius - innerRadius) / barHeight;
        
        color = hsv2rgb(vec3(hue, 0.8, brightness * 0.9 + 0.1));
        
        float glowDist = abs(radius - outerRadius) / barHeight;
        color += vec3(1.0) * (1.0 - smoothstep(0.0, 0.05, glowDist)) * 0.5;
    }
    
    return color;
}

void main() {
    vec2 iResolution = vec2(1920.0, 1080.0);
    vec2 uv = gl_FragCoord.xy / iResolution.xy;
    
    vec3 color = vec3(0.0);
    
    int barCount = int(u_barCount);
    int visualMode = int(u_visualMode);
    
    if (visualMode == 0) {
        // Bar mode
        color = renderBars(uv, barCount, u_barSpacing, u_heightScale);
    } else if (visualMode == 1) {
        // Waveform mode
        color = renderWaveform(uv, u_heightScale);
    } else {
        // Circular mode
        color = renderCircular(uv, barCount, u_heightScale);
    }
    
    // Add beat pulse
    float beatIntensity = beatPulse(iBeat, 0.1, 0.9);
    color += vec3(beatIntensity * 0.1);
    
    // Background gradient
    vec3 bgGradient = vec3(0.0, 0.0, 0.05) * (1.0 - uv.y);
    color = mix(bgGradient, color, step(0.01, length(color)));
    
    gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
}]]>
        </FragmentShaderSource>
      </Shader>
    </Material>
  </Content>
</ZApplication>
